[{"/Users/jasonvail/Desktop/devProjects/pathvisualizer/src/index.js":"1","/Users/jasonvail/Desktop/devProjects/pathvisualizer/src/App.js":"2","/Users/jasonvail/Desktop/devProjects/pathvisualizer/src/PathfindingVisualizer/PathfindingVisualizer.jsx":"3","/Users/jasonvail/Desktop/devProjects/pathvisualizer/src/PathfindingVisualizer/NavBar.jsx":"4","/Users/jasonvail/Desktop/devProjects/pathvisualizer/src/algorithms/algorithms.js":"5","/Users/jasonvail/Desktop/devProjects/pathvisualizer/src/PathfindingVisualizer/Node/Node.jsx":"6","/Users/jasonvail/Desktop/devProjects/pathvisualizer/src/PathfindingVisualizer/DropdownMenu.jsx":"7"},{"size":219,"mtime":1611701533124,"results":"8","hashOfConfig":"9"},{"size":490,"mtime":1611875518631,"results":"10","hashOfConfig":"9"},{"size":11839,"mtime":1611877119880,"results":"11","hashOfConfig":"9"},{"size":1766,"mtime":1611704040463,"results":"12","hashOfConfig":"9"},{"size":4482,"mtime":1611700123195,"results":"13","hashOfConfig":"9"},{"size":757,"mtime":1611628660259,"results":"14","hashOfConfig":"9"},{"size":775,"mtime":1611699536968,"results":"15","hashOfConfig":"9"},{"filePath":"16","messages":"17","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},"yoetat",{"filePath":"19","messages":"20","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"21","usedDeprecatedRules":"18"},{"filePath":"22","messages":"23","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"24","usedDeprecatedRules":"18"},{"filePath":"25","messages":"26","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"27","usedDeprecatedRules":"18"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},{"filePath":"30","messages":"31","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"34","usedDeprecatedRules":"35"},"/Users/jasonvail/Desktop/devProjects/pathvisualizer/src/index.js",[],["36","37"],"/Users/jasonvail/Desktop/devProjects/pathvisualizer/src/App.js",["38"],"import \"./App.css\";\nimport PathfindingVisualizer from \"./PathfindingVisualizer/PathfindingVisualizer.jsx\";\nimport {\n  Breakpoint,\n  BreakpointProvider,\n  setDefaultBreakpoints\n} from \"react-socks\";\n\n//screen sizes for responsivness\nsetDefaultBreakpoints([{ small: 576 }, { medium: 768 }, { large: 1250 }]);\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <BreakpointProvider>\n        <PathfindingVisualizer />\n      </BreakpointProvider>\n    </div>\n  );\n}\n\nexport default App;\n","/Users/jasonvail/Desktop/devProjects/pathvisualizer/src/PathfindingVisualizer/PathfindingVisualizer.jsx",["39","40","41","42"],"import { useEffect, useState, useRef } from \"react\";\nimport Node from \"./Node/Node\";\nimport \"./PathfindingVisualizer.css\";\nimport {\n  dijkstra,\n  dfs,\n  bfs,\n  aStar,\n  getNodesInShortestPathOrder\n} from \"../algorithms/algorithms\";\nimport NavBar from \"./NavBar.jsx\";\nimport { BreakpointProvider, Breakpoint } from \"react-socks\";\n\nconst PathfindingVisualizer = () => {\n  const [grid, setGrid] = useState([]);\n  const visualizerOnBoard = useRef(false);\n  const visualizerIsRunning = useRef(false);\n  const mouseDownRef = useRef(false);\n  const startNodeMovingRef = useRef(false);\n  const finishNodeMovingRef = useRef(false);\n  const startNodePosRef = useRef([10, 15]);\n  const finishNodePosRef = useRef([10, 35]);\n  const checkPointOnBoard = useRef(false);\n  const checkPointPosRef = useRef([5, 25]);\n  const checkPointMovingRef = useRef(false);\n  const addCheckPointOnNav = useRef(true);\n\n  useEffect(() => {\n    const newGrid = getGrid(true, false);\n    setGrid(newGrid);\n  }, []);\n\n  const algorithms = [0, dijkstra, dfs, bfs, aStar];\n\n  /*\n  - we need deep copy to prevent corrupting state\n  - called for any algorithm \n  */\n  const animateAlgorithm = (\n    visitedNodesInOrder,\n    nodesFromStartToCheckPoint\n  ) => {\n    for (let i = 0; i <= visitedNodesInOrder.length; ++i) {\n      if (i === visitedNodesInOrder.length) {\n        let nodesInShortestPathOrder;\n        if (\n          //there is no path from startNode to finishNode\n          visitedNodesInOrder[i - 1].row !== finishNodePosRef.current[0] ||\n          visitedNodesInOrder[i - 1].col !== finishNodePosRef.current[1]\n        ) {\n          visualizerIsRunning.current = false;\n          return;\n        }\n        setTimeout(() => {\n          console.log(visitedNodesInOrder[i - 1]);\n          nodesInShortestPathOrder = getNodesInShortestPathOrder(\n            visitedNodesInOrder[i - 1]\n          );\n          if (checkPointOnBoard.current) {\n            nodesInShortestPathOrder.unshift();\n            nodesInShortestPathOrder = [\n              ...getNodesInShortestPathOrder(\n                nodesFromStartToCheckPoint[checkPointPosRef.current[0]][\n                  checkPointPosRef.current[1]\n                ]\n              ),\n              ...nodesInShortestPathOrder\n            ];\n          }\n          for (let j = 0; j <= nodesInShortestPathOrder.length; ++j) {\n            if (j === nodesInShortestPathOrder.length) {\n              setTimeout(() => {\n                visualizerIsRunning.current = false;\n              }, j * 10);\n              return;\n            }\n            setTimeout(() => {\n              setGrid(grid => {\n                const node = nodesInShortestPathOrder[j];\n                const gridCopy = [];\n                for (const row of grid) {\n                  const rowCopy = [];\n                  for (const node of row) {\n                    rowCopy.push({ ...node });\n                  }\n                  gridCopy.push(rowCopy);\n                }\n                gridCopy[node.row][node.col] = node;\n                return gridCopy;\n              });\n            }, j * 10); //note: j*10 is j*10 milliseconds from when the scheduled enclosing function STARTS executing\n          }\n        }, i * 10);\n        return;\n      }\n\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        setGrid(grid => {\n          const gridCopy = [];\n          for (const row of grid) {\n            const rowCopy = [];\n            for (const node of row) {\n              rowCopy.push({ ...node });\n            }\n            gridCopy.push(rowCopy);\n          }\n          gridCopy[node.row][node.col] = node;\n          return gridCopy;\n        });\n      }, i * 10);\n    }\n  };\n\n  const visualizeAlgorithm = algNumber => {\n    if (!algNumber) return; //no alg selected\n    if (visualizerOnBoard.current) return; //visualization has not been cleared\n    visualizerIsRunning.current = true;\n    visualizerOnBoard.current = true;\n    let gridCopy = [];\n    for (const row of grid) {\n      const rowCopy = [];\n      for (const node of row) {\n        rowCopy.push({ ...node });\n      }\n      gridCopy.push(rowCopy);\n    }\n    let visitedNodesInOrder;\n    let startNode =\n      gridCopy[startNodePosRef.current[0]][startNodePosRef.current[1]];\n    let nodesFromStartToCheckPoint; //used only for checkpoints\n    if (checkPointOnBoard.current) {\n      //how to handle checkpoint\n      let finishNode =\n        gridCopy[checkPointPosRef.current[0]][checkPointPosRef.current[1]];\n      visitedNodesInOrder = algorithms[algNumber](\n        gridCopy,\n        startNode,\n        finishNode\n      );\n      //dijkstra(gridCopy, startNode, finishNode);\n      nodesFromStartToCheckPoint = gridCopy;\n      visitedNodesInOrder.pop();\n      gridCopy = [];\n      for (const row of grid) {\n        const rowCopy = [];\n        for (const node of row) {\n          rowCopy.push({ ...node });\n        }\n        gridCopy.push(rowCopy);\n      }\n      startNode =\n        gridCopy[checkPointPosRef.current[0]][checkPointPosRef.current[1]];\n      finishNode =\n        gridCopy[finishNodePosRef.current[0]][finishNodePosRef.current[1]];\n      visitedNodesInOrder = [\n        ...visitedNodesInOrder,\n        ...algorithms[algNumber](gridCopy, startNode, finishNode)\n      ];\n    } else {\n      const finishNode =\n        gridCopy[finishNodePosRef.current[0]][finishNodePosRef.current[1]];\n      visitedNodesInOrder = algorithms[algNumber](\n        gridCopy,\n        startNode,\n        finishNode\n      );\n    }\n    animateAlgorithm(visitedNodesInOrder, nodesFromStartToCheckPoint);\n  };\n\n  const getNewGridWithWallToggled = (row, col) => {\n    const gridCopy = [];\n    for (const row of grid) {\n      const rowCopy = [];\n      for (const node of row) {\n        rowCopy.push({ ...node });\n      }\n      gridCopy.push(rowCopy);\n    }\n    const node = gridCopy[row][col];\n    const newNode = {\n      ...node,\n      isWall: !node.isWall\n    };\n    gridCopy[row][col] = newNode;\n    return gridCopy;\n  };\n\n  //isFresh - true if grid should be created with nodes with default ('fresh') properties\n  const getGrid = (isFresh, withCheckPoint) => {\n    const newGrid = [];\n    for (let row = 0; row < 15; ++row) {\n      const currentRow = [];\n      for (let col = 0; col < 50; ++col) {\n        currentRow.push(createNode(col, row, isFresh, withCheckPoint));\n      }\n      newGrid.push(currentRow);\n    }\n    return newGrid;\n  };\n\n  const createNode = (col, row, isFresh, withCheckPoint) => {\n    return {\n      col,\n      isStart:\n        row === startNodePosRef.current[0] &&\n        col === startNodePosRef.current[1],\n      isFinish:\n        row === finishNodePosRef.current[0] &&\n        col === finishNodePosRef.current[1],\n      inShortestPath: false,\n      distance: Infinity,\n      isVisited: false,\n      isWall: isFresh\n        ? false\n        : row === startNodePosRef.current[0] &&\n          col === startNodePosRef.current[1]\n        ? false\n        : row === finishNodePosRef.current[0] &&\n          col === finishNodePosRef.current[1]\n        ? false\n        : row === checkPointPosRef.current[0] &&\n          col === checkPointPosRef.current[1]\n        ? false\n        : grid.length > 0\n        ? grid[row][col].isWall\n        : false,\n      previousNode: null,\n      isCheckPoint: !withCheckPoint\n        ? false\n        : row === checkPointPosRef.current[0] &&\n          col === checkPointPosRef.current[1]\n        ? true\n        : false,\n      fScore: Infinity,\n      row\n    };\n  };\n\n  //Event Handlers\n\n  const handleMouseDown = (row, col) => {\n    if (visualizerOnBoard.current) return;\n    mouseDownRef.current = true;\n    if (\n      row === checkPointPosRef.current[0] &&\n      col === checkPointPosRef.current[1]\n    ) {\n      checkPointMovingRef.current = true;\n      return;\n    }\n    if (\n      row === startNodePosRef.current[0] &&\n      col === startNodePosRef.current[1]\n    ) {\n      startNodeMovingRef.current = true;\n      return;\n    }\n    if (\n      row === finishNodePosRef.current[0] &&\n      col === finishNodePosRef.current[1]\n    ) {\n      finishNodeMovingRef.current = true;\n      return;\n    }\n    setGrid(getNewGridWithWallToggled(row, col));\n  };\n\n  const handleMouseEnter = (row, col) => {\n    if (!mouseDownRef.current) return;\n    if (checkPointMovingRef.current) {\n      checkPointPosRef.current = [row, col];\n      const newGrid = getGrid(false, checkPointOnBoard.current);\n      setGrid(newGrid);\n      return;\n    }\n    if (startNodeMovingRef.current) {\n      startNodePosRef.current = [row, col];\n      const newGrid = getGrid(false, checkPointOnBoard.current);\n      setGrid(newGrid);\n      return;\n    }\n    if (finishNodeMovingRef.current) {\n      finishNodePosRef.current = [row, col];\n      const newGrid = getGrid(false, checkPointOnBoard.current);\n      setGrid(newGrid);\n      return;\n    }\n    if (\n      (row !== startNodePosRef.current[0] ||\n        col !== startNodePosRef.current[1]) &&\n      (row !== finishNodePosRef.current[0] ||\n        col !== finishNodePosRef.current[1]) &&\n      (row !== checkPointPosRef.current[0] ||\n        col !== checkPointPosRef.current[1])\n    )\n      setGrid(getNewGridWithWallToggled(row, col));\n  };\n\n  const handleMouseUp = () => {\n    finishNodeMovingRef.current = false;\n    startNodeMovingRef.current = false;\n    checkPointMovingRef.current = false;\n    mouseDownRef.current = false;\n  };\n\n  const handleRestart = () => {\n    if (visualizerIsRunning.current) return;\n    visualizerOnBoard.current = false;\n    checkPointOnBoard.current = false;\n    addCheckPointOnNav.current = true;\n    //restarts start and finish nodes\n    startNodePosRef.current = [10, 15];\n    finishNodePosRef.current = [10, 35];\n    setGrid(getGrid(true, checkPointOnBoard.current));\n  };\n\n  const handleClearVisualization = () => {\n    if (visualizerIsRunning.current) return;\n    visualizerOnBoard.current = false;\n    setGrid(getGrid(false, checkPointOnBoard.current));\n  };\n\n  const handleClearBarriers = () => {\n    if (visualizerOnBoard.current) return;\n    setGrid(getGrid(true, checkPointOnBoard.current));\n  };\n\n  const handleAddCheckPoint = () => {\n    if (visualizerOnBoard.current) return;\n    checkPointOnBoard.current = !checkPointOnBoard.current;\n    addCheckPointOnNav.current = !addCheckPointOnNav.current;\n    setGrid(getGrid(false, checkPointOnBoard.current));\n  };\n\n  return (\n    <>\n      <NavBar\n        visualizeAlgorithm={visualizeAlgorithm}\n        onClearVis={handleClearVisualization}\n        onRestart={handleRestart}\n        onClearBarriers={handleClearBarriers}\n        onAddCheckPoint={handleAddCheckPoint}\n        add={addCheckPointOnNav.current}\n      />\n\n      <div className=\"grid\">\n        {grid.map((row, rowIdx) => {\n          return (\n            <div key={rowIdx}>\n              {row.map((node, nodeIdx) => {\n                const {\n                  row,\n                  isStart,\n                  isFinish,\n                  inShortestPath,\n                  isVisited,\n                  isWall,\n                  isCheckPoint,\n                  col\n                } = node;\n                return (\n                  <Node\n                    col={col}\n                    key={nodeIdx}\n                    isFinish={isFinish}\n                    isStart={isStart}\n                    inShortestPath={inShortestPath}\n                    isVisited={isVisited}\n                    isWall={isWall}\n                    isCheckPoint={isCheckPoint}\n                    onMouseUp={handleMouseUp}\n                    onMouseDown={handleMouseDown}\n                    onMouseEnter={handleMouseEnter}\n                    row={row}\n                  ></Node>\n                );\n              })}\n            </div>\n          );\n        })}\n      </div>\n      <div className=\"credit\">By Jason Vail</div>\n    </>\n  );\n};\n\nexport default PathfindingVisualizer;\n","/Users/jasonvail/Desktop/devProjects/pathvisualizer/src/PathfindingVisualizer/NavBar.jsx",["43","44","45","46","47","48"],"import \"./NavBar.css\";\nimport DropdownMenu from \"./DropdownMenu\";\nimport { useState } from \"react\";\n\nconst NavBar = props => {\n  const [algorithmSelected, setAlgorithmSelected] = useState(0);\n\n  const algorithms = [\n    \"dummy\",\n    \"Visualize Dijkstra's!\",\n    \"Visualize Depth-First Search!\",\n    \"Visualize Breadth-First Search!\",\n    \"Visualize A*!\"\n  ];\n\n  const {\n    visualizeAlgorithm,\n    onRestart,\n    onClearBarriers,\n    onClearVis,\n    onAddCheckPoint,\n    add\n  } = props;\n\n  const NavItem = props => {\n    const [open, setOpen] = useState(false);\n    return (\n      <li className=\"nav-item\">\n        <a onClick={() => setOpen(!open)}>Algorithms</a>\n        {open && props.children}\n      </li>\n    );\n  };\n\n  const handleDropdownSelect = algNumber => {\n    setAlgorithmSelected(algNumber);\n  };\n\n  return (\n    <div>\n      <nav>\n        <div className=\"logo\">Path Algo Visualizer</div>\n        <NavItem>\n          <DropdownMenu handleDropdownSelect={handleDropdownSelect} />\n        </NavItem>\n        <button\n          className=\"mainButton\"\n          onClick={() => visualizeAlgorithm(algorithmSelected)}\n        >\n          {(algorithmSelected && algorithms[algorithmSelected]) || (\n            <>Choose An Algorithm!</>\n          )}\n        </button>\n        <ul className=\"nav-links\">\n          <li onClick={onRestart}>\n            <a>Restart</a>\n          </li>\n          <li onClick={onClearBarriers}>\n            <a>Clear Barriers</a>\n          </li>\n          <li onClick={onClearVis}>\n            <a>Clear Visualization</a>\n          </li>\n          <li onClick={onAddCheckPoint}>\n            {(add && <a>Add Checkpoint</a>) || <a>Remove Checkpoint</a>}\n          </li>\n        </ul>\n      </nav>\n    </div>\n  );\n};\n\nexport default NavBar;\n","/Users/jasonvail/Desktop/devProjects/pathvisualizer/src/algorithms/algorithms.js",[],"/Users/jasonvail/Desktop/devProjects/pathvisualizer/src/PathfindingVisualizer/Node/Node.jsx",[],"/Users/jasonvail/Desktop/devProjects/pathvisualizer/src/PathfindingVisualizer/DropdownMenu.jsx",["49"],"import \"./DropdownMenu.css\";\n\nconst DropdownMenu = props => {\n  const { handleDropdownSelect } = props;\n  const DropdownItem = props => {\n    const { onclick } = props;\n\n    return (\n      <a className=\"menu-item\" onClick={onclick}>\n        {props.children}\n      </a>\n    );\n  };\n\n  return (\n    <div className=\"dropdown\">\n      <DropdownItem onclick={() => handleDropdownSelect(1)}>\n        Dijkstra's\n      </DropdownItem>\n      <DropdownItem onclick={() => handleDropdownSelect(2)}>\n        Depth-First Search\n      </DropdownItem>\n      <DropdownItem onclick={() => handleDropdownSelect(3)}>\n        Breadth-First Search\n      </DropdownItem>\n      <DropdownItem onclick={() => handleDropdownSelect(4)}>A*</DropdownItem>\n    </div>\n  );\n};\n\nexport default DropdownMenu;\n",["50","51"],{"ruleId":"52","replacedBy":"53"},{"ruleId":"54","replacedBy":"55"},{"ruleId":"56","severity":1,"message":"57","line":4,"column":3,"nodeType":"58","messageId":"59","endLine":4,"endColumn":13},{"ruleId":"56","severity":1,"message":"60","line":12,"column":10,"nodeType":"58","messageId":"59","endLine":12,"endColumn":28},{"ruleId":"56","severity":1,"message":"57","line":12,"column":30,"nodeType":"58","messageId":"59","endLine":12,"endColumn":40},{"ruleId":"61","severity":1,"message":"62","line":31,"column":6,"nodeType":"63","endLine":31,"endColumn":8,"suggestions":"64"},{"ruleId":"65","severity":1,"message":"66","line":77,"column":24,"nodeType":"67","messageId":"68","endLine":91,"endColumn":14},{"ruleId":"69","severity":1,"message":"70","line":29,"column":9,"nodeType":"71","endLine":29,"endColumn":43},{"ruleId":"69","severity":1,"message":"70","line":56,"column":13,"nodeType":"71","endLine":56,"endColumn":16},{"ruleId":"69","severity":1,"message":"70","line":59,"column":13,"nodeType":"71","endLine":59,"endColumn":16},{"ruleId":"69","severity":1,"message":"70","line":62,"column":13,"nodeType":"71","endLine":62,"endColumn":16},{"ruleId":"69","severity":1,"message":"70","line":65,"column":22,"nodeType":"71","endLine":65,"endColumn":25},{"ruleId":"69","severity":1,"message":"70","line":65,"column":48,"nodeType":"71","endLine":65,"endColumn":51},{"ruleId":"69","severity":1,"message":"70","line":9,"column":7,"nodeType":"71","endLine":9,"endColumn":50},{"ruleId":"52","replacedBy":"72"},{"ruleId":"54","replacedBy":"73"},"no-native-reassign",["74"],"no-negated-in-lhs",["75"],"no-unused-vars","'Breakpoint' is defined but never used.","Identifier","unusedVar","'BreakpointProvider' is defined but never used.","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'getGrid'. Either include it or remove the dependency array.","ArrayExpression",["76"],"no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'nodesInShortestPathOrder'.","ArrowFunctionExpression","unsafeRefs","jsx-a11y/anchor-is-valid","The href attribute is required for an anchor to be keyboard accessible. Provide a valid, navigable address as the href value. If you cannot provide an href, but still need the element to resemble a link, use a button and change it with appropriate styles. Learn more: https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/anchor-is-valid.md","JSXOpeningElement",["74"],["75"],"no-global-assign","no-unsafe-negation",{"desc":"77","fix":"78"},"Update the dependencies array to be: [getGrid]",{"range":"79","text":"80"},[977,979],"[getGrid]"]