{"version":3,"sources":["PathfindingVisualizer/Node/Node.jsx","algorithms/algorithms.js","PathfindingVisualizer/DropdownMenu.jsx","PathfindingVisualizer/NavBar.jsx","PathfindingVisualizer/PathfindingVisualizer.jsx","App.js","index.js"],"names":["Node","props","col","isFinish","isStart","isVisited","inShortestPath","isWall","onMouseDown","onMouseEnter","onMouseUp","isCheckPoint","row","extraClassName","id","className","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","push","updateUnvisitedNeighborsDijkstra","dfs","stack","node","pop","unvisitedNeighbors","getUnvisitedNeighbors","i","previousNode","bfs","queue","unshift","aStar","fScore","Math","abs","sortNodesByFScore","updateUnvisitedNeighborsAStar","sort","a","b","neighbors","neighbor","filter","nodes","getNodesInShortestPathOrder","nodesInShortestPathOrder","currentNode","DropdownMenu","handleDropdownSelect","DropdownItem","onclick","onClick","children","NavBar","useState","algorithmSelected","setAlgorithmSelected","visualizeAlgorithm","onRestart","onClearBarriers","onClearVis","onAddCheckPoint","add","NavItem","open","setOpen","algNumber","PathfindingVisualizer","setGrid","visualizerOnBoard","useRef","visualizerIsRunning","mouseDownRef","startNodeMovingRef","finishNodeMovingRef","startNodePosRef","finishNodePosRef","checkPointOnBoard","checkPointPosRef","checkPointMovingRef","addCheckPointOnNav","useEffect","newGrid","getGrid","algorithms","getNewGridWithWallToggled","gridCopy","rowCopy","newNode","isFresh","withCheckPoint","currentRow","createNode","current","handleMouseDown","handleMouseEnter","handleMouseUp","nodesFromStartToCheckPoint","setTimeout","console","log","j","animateAlgorithm","map","rowIdx","nodeIdx","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.ff8f8803.chunk.js","sourcesContent":["import \"./Node.css\";\n\nconst Node = props => {\n  const {\n    col,\n    isFinish,\n    isStart,\n    isVisited,\n    inShortestPath,\n    isWall,\n    onMouseDown,\n    onMouseEnter,\n    onMouseUp,\n    isCheckPoint,\n    row\n  } = props;\n\n  const extraClassName = isWall\n    ? \"node-wall\"\n    : inShortestPath\n    ? \"node-shortest-path\"\n    : isVisited\n    ? \"node-visited\"\n    : isStart\n    ? \"node-start\"\n    : isFinish\n    ? \"node-finish\"\n    : isCheckPoint\n    ? \"node-checkpoint\"\n    : \"\";\n\n  return (\n    <div\n      id={`node-${row}-${col}`}\n      className={`node ${extraClassName}`}\n      onMouseDown={() => onMouseDown(row, col)}\n      onMouseEnter={() => onMouseEnter(row, col)}\n      onMouseUp={() => onMouseUp()}\n    ></div>\n  );\n};\n\nexport default Node;\n","//dijkstra\nexport const dijkstra = (grid, startNode, finishNode) => {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    if (closestNode.isWall) continue;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighborsDijkstra(closestNode, grid);\n  }\n};\n\nexport const dfs = (grid, startNode, finishNode) => {\n  const visitedNodesInOrder = [];\n  startNode.isVisited = true;\n  const stack = [];\n  stack.push(startNode);\n  while (stack.length > 0) {\n    const node = stack.pop();\n    visitedNodesInOrder.push(node);\n    if (node.row === finishNode.row && node.col === finishNode.col)\n      return visitedNodesInOrder;\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n    for (let i = 0; i < unvisitedNeighbors.length; ++i) {\n      if (unvisitedNeighbors[i].isWall) continue;\n      unvisitedNeighbors[i].isVisited = true;\n      unvisitedNeighbors[i].previousNode = node;\n      stack.push(unvisitedNeighbors[i]);\n    }\n  }\n  return visitedNodesInOrder;\n};\n\nexport const bfs = (grid, startNode, finishNode) => {\n  const visitedNodesInOrder = [];\n  startNode.isVisited = true;\n  const queue = [];\n  queue.unshift(startNode);\n  while (queue.length > 0) {\n    const node = queue.pop();\n    visitedNodesInOrder.push(node);\n    if (node.row === finishNode.row && node.col === finishNode.col)\n      return visitedNodesInOrder;\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n    for (let i = 0; i < unvisitedNeighbors.length; ++i) {\n      if (unvisitedNeighbors[i].isWall) continue;\n      unvisitedNeighbors[i].isVisited = true;\n      unvisitedNeighbors[i].previousNode = node;\n      queue.unshift(unvisitedNeighbors[i]);\n    }\n  }\n  return visitedNodesInOrder;\n};\n\nexport const aStar = (grid, startNode, finishNode) => {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  startNode.fScore =\n    Math.abs(finishNode.col - startNode.col) +\n    Math.abs(finishNode.row - startNode.row);\n  const unvisitedNodes = getAllNodes(grid);\n  while (!!unvisitedNodes.length) {\n    sortNodesByFScore(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    if (closestNode.fScore === Infinity) return visitedNodesInOrder;\n    if (closestNode.isWall) continue;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighborsAStar(closestNode, finishNode, grid);\n  }\n};\n\nconst sortNodesByFScore = unvisitedNodes => {\n  unvisitedNodes.sort((a, b) => a.fScore - b.fScore);\n};\n\nconst sortNodesByDistance = unvisitedNodes => {\n  unvisitedNodes.sort((a, b) => a.distance - b.distance);\n};\n\nconst updateUnvisitedNeighborsAStar = (node, finishNode, grid) => {\n  const neighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of neighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.fScore =\n      Math.abs(finishNode.col - neighbor.col) +\n      Math.abs(finishNode.row - neighbor.row);\n    neighbor.previousNode = node;\n  }\n};\n\nconst updateUnvisitedNeighborsDijkstra = (node, grid) => {\n  const neighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of neighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n};\n\nconst getUnvisitedNeighbors = (node, grid) => {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n};\n\nconst getAllNodes = grid => {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n};\n\nexport const getNodesInShortestPathOrder = finishNode => {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    currentNode.inShortestPath = true;\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n};\n","import \"./DropdownMenu.css\";\n\nconst DropdownMenu = props => {\n  const { handleDropdownSelect } = props;\n  const DropdownItem = props => {\n    const { onclick } = props;\n\n    return (\n      <a className=\"menu-item\" onClick={onclick}>\n        {props.children}\n      </a>\n    );\n  };\n\n  return (\n    <div className=\"dropdown\">\n      <DropdownItem onclick={() => handleDropdownSelect(1)}>\n        Dijkstra's\n      </DropdownItem>\n      <DropdownItem onclick={() => handleDropdownSelect(2)}>\n        Depth-First Search\n      </DropdownItem>\n      <DropdownItem onclick={() => handleDropdownSelect(3)}>\n        Breadth-First Search\n      </DropdownItem>\n      <DropdownItem onclick={() => handleDropdownSelect(4)}>A*</DropdownItem>\n    </div>\n  );\n};\n\nexport default DropdownMenu;\n","import \"./NavBar.css\";\nimport DropdownMenu from \"./DropdownMenu\";\nimport { useState } from \"react\";\n\nconst NavBar = props => {\n  const [algorithmSelected, setAlgorithmSelected] = useState(0);\n\n  const algorithms = [\n    \"dummy\",\n    \"Visualize Dijkstra's!\",\n    \"Visualize Depth-First Search!\",\n    \"Visualize Breadth-First Search!\",\n    \"Visualize A*!\"\n  ];\n\n  const {\n    visualizeAlgorithm,\n    onRestart,\n    onClearBarriers,\n    onClearVis,\n    onAddCheckPoint,\n    add\n  } = props;\n\n  const NavItem = props => {\n    const [open, setOpen] = useState(false);\n    return (\n      <li className=\"nav-item\">\n        <a onClick={() => setOpen(!open)}>Algorithms</a>\n        {open && props.children}\n      </li>\n    );\n  };\n\n  const handleDropdownSelect = algNumber => {\n    setAlgorithmSelected(algNumber);\n  };\n\n  return (\n    <div>\n      <nav>\n        <div className=\"logo\">Path Algo Visualizer</div>\n        <NavItem>\n          <DropdownMenu handleDropdownSelect={handleDropdownSelect} />\n        </NavItem>\n        <button\n          className=\"mainButton\"\n          onClick={() => visualizeAlgorithm(algorithmSelected)}\n        >\n          {(algorithmSelected && algorithms[algorithmSelected]) || (\n            <>Choose An Algorithm!</>\n          )}\n        </button>\n        <ul className=\"nav-links\">\n          <li onClick={onRestart}>\n            <a>Restart</a>\n          </li>\n          <li onClick={onClearBarriers}>\n            <a>Clear Barriers</a>\n          </li>\n          <li onClick={onClearVis}>\n            <a>Clear Visualization</a>\n          </li>\n          <li onClick={onAddCheckPoint}>\n            {(add && <a>Add Checkpoint</a>) || <a>Remove Checkpoint</a>}\n          </li>\n        </ul>\n      </nav>\n    </div>\n  );\n};\n\nexport default NavBar;\n","import { useEffect, useState, useRef } from \"react\";\nimport Node from \"./Node/Node\";\nimport \"./PathfindingVisualizer.css\";\nimport {\n  dijkstra,\n  dfs,\n  bfs,\n  aStar,\n  getNodesInShortestPathOrder\n} from \"../algorithms/algorithms\";\nimport NavBar from \"./NavBar.jsx\";\n\nconst PathfindingVisualizer = () => {\n  const [grid, setGrid] = useState([]);\n  const visualizerOnBoard = useRef(false);\n  const visualizerIsRunning = useRef(false);\n  const mouseDownRef = useRef(false);\n  const startNodeMovingRef = useRef(false);\n  const finishNodeMovingRef = useRef(false);\n  const startNodePosRef = useRef([10, 15]);\n  const finishNodePosRef = useRef([10, 35]);\n  const checkPointOnBoard = useRef(false);\n  const checkPointPosRef = useRef([5, 25]);\n  const checkPointMovingRef = useRef(false);\n  const addCheckPointOnNav = useRef(true);\n\n  useEffect(() => {\n    const newGrid = getGrid(true, false);\n    setGrid(newGrid);\n  }, []);\n\n  const algorithms = [0, dijkstra, dfs, bfs, aStar];\n\n  /*\n  - we need deep copy to prevent corrupting state\n  - called for any algorithm \n  */\n  const animateAlgorithm = (\n    visitedNodesInOrder,\n    nodesFromStartToCheckPoint\n  ) => {\n    for (let i = 0; i <= visitedNodesInOrder.length; ++i) {\n      if (i === visitedNodesInOrder.length) {\n        let nodesInShortestPathOrder;\n        if (\n          visitedNodesInOrder[i - 1].row !== finishNodePosRef.current[0] ||\n          visitedNodesInOrder[i - 1].col !== finishNodePosRef.current[1]\n        ) {\n          visualizerIsRunning.current = false;\n          return;\n        }\n        setTimeout(() => {\n          console.log(visitedNodesInOrder[i - 1]);\n          nodesInShortestPathOrder = getNodesInShortestPathOrder(\n            visitedNodesInOrder[i - 1]\n          );\n          if (checkPointOnBoard.current) {\n            nodesInShortestPathOrder.unshift();\n            nodesInShortestPathOrder = [\n              ...getNodesInShortestPathOrder(\n                nodesFromStartToCheckPoint[checkPointPosRef.current[0]][\n                  checkPointPosRef.current[1]\n                ]\n              ),\n              ...nodesInShortestPathOrder\n            ];\n          }\n          for (let j = 0; j <= nodesInShortestPathOrder.length; ++j) {\n            if (j === nodesInShortestPathOrder.length) {\n              setTimeout(() => {\n                visualizerIsRunning.current = false;\n              }, j * 10);\n              return;\n            }\n            setTimeout(() => {\n              setGrid(grid => {\n                const node = nodesInShortestPathOrder[j];\n                const gridCopy = [];\n                for (const row of grid) {\n                  const rowCopy = [];\n                  for (const node of row) {\n                    rowCopy.push({ ...node });\n                  }\n                  gridCopy.push(rowCopy);\n                }\n                gridCopy[node.row][node.col] = node;\n                return gridCopy;\n              });\n            }, j * 10); //note: j*10 is j*10 milliseconds from when the scheduled enclosing function STARTS executing\n          }\n        }, i * 10);\n        return;\n      }\n\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        setGrid(grid => {\n          const gridCopy = [];\n          for (const row of grid) {\n            const rowCopy = [];\n            for (const node of row) {\n              rowCopy.push({ ...node });\n            }\n            gridCopy.push(rowCopy);\n          }\n          gridCopy[node.row][node.col] = node;\n          return gridCopy;\n        });\n      }, i * 10);\n    }\n  };\n\n  const visualizeAlgorithm = algNumber => {\n    if (!algNumber) return; //no alg selected\n    if (visualizerOnBoard.current) return; //visualization has not been cleared\n    visualizerIsRunning.current = true;\n    visualizerOnBoard.current = true;\n    let gridCopy = [];\n    for (const row of grid) {\n      const rowCopy = [];\n      for (const node of row) {\n        rowCopy.push({ ...node });\n      }\n      gridCopy.push(rowCopy);\n    }\n    let visitedNodesInOrder;\n    let startNode =\n      gridCopy[startNodePosRef.current[0]][startNodePosRef.current[1]];\n    let nodesFromStartToCheckPoint; //used only for checkpoints\n    if (checkPointOnBoard.current) {\n      //how to handle checkpoint\n      let finishNode =\n        gridCopy[checkPointPosRef.current[0]][checkPointPosRef.current[1]];\n      visitedNodesInOrder = algorithms[algNumber](\n        gridCopy,\n        startNode,\n        finishNode\n      );\n      //dijkstra(gridCopy, startNode, finishNode);\n      nodesFromStartToCheckPoint = gridCopy;\n      visitedNodesInOrder.pop();\n      gridCopy = [];\n      for (const row of grid) {\n        const rowCopy = [];\n        for (const node of row) {\n          rowCopy.push({ ...node });\n        }\n        gridCopy.push(rowCopy);\n      }\n      startNode =\n        gridCopy[checkPointPosRef.current[0]][checkPointPosRef.current[1]];\n      finishNode =\n        gridCopy[finishNodePosRef.current[0]][finishNodePosRef.current[1]];\n      visitedNodesInOrder = [\n        ...visitedNodesInOrder,\n        ...algorithms[algNumber](gridCopy, startNode, finishNode)\n      ];\n    } else {\n      const finishNode =\n        gridCopy[finishNodePosRef.current[0]][finishNodePosRef.current[1]];\n      visitedNodesInOrder = algorithms[algNumber](\n        gridCopy,\n        startNode,\n        finishNode\n      );\n    }\n    animateAlgorithm(visitedNodesInOrder, nodesFromStartToCheckPoint);\n  };\n\n  const getNewGridWithWallToggled = (row, col) => {\n    const gridCopy = [];\n    for (const row of grid) {\n      const rowCopy = [];\n      for (const node of row) {\n        rowCopy.push({ ...node });\n      }\n      gridCopy.push(rowCopy);\n    }\n    const node = gridCopy[row][col];\n    const newNode = {\n      ...node,\n      isWall: !node.isWall\n    };\n    gridCopy[row][col] = newNode;\n    return gridCopy;\n  };\n\n  //isFresh - true if grid should be created with nodes with default ('fresh') properties\n  const getGrid = (isFresh, withCheckPoint) => {\n    const newGrid = [];\n    for (let row = 0; row < 15; ++row) {\n      const currentRow = [];\n      for (let col = 0; col < 50; ++col) {\n        currentRow.push(createNode(col, row, isFresh, withCheckPoint));\n      }\n      newGrid.push(currentRow);\n    }\n    return newGrid;\n  };\n\n  const createNode = (col, row, isFresh, withCheckPoint) => {\n    return {\n      col,\n      isStart:\n        row === startNodePosRef.current[0] &&\n        col === startNodePosRef.current[1],\n      isFinish:\n        row === finishNodePosRef.current[0] &&\n        col === finishNodePosRef.current[1],\n      inShortestPath: false,\n      distance: Infinity,\n      isVisited: false,\n      isWall: isFresh\n        ? false\n        : row === startNodePosRef.current[0] &&\n          col === startNodePosRef.current[1]\n        ? false\n        : row === finishNodePosRef.current[0] &&\n          col === finishNodePosRef.current[1]\n        ? false\n        : row === checkPointPosRef.current[0] &&\n          col === checkPointPosRef.current[1]\n        ? false\n        : grid.length > 0\n        ? grid[row][col].isWall\n        : false,\n      previousNode: null,\n      isCheckPoint: !withCheckPoint\n        ? false\n        : row === checkPointPosRef.current[0] &&\n          col === checkPointPosRef.current[1]\n        ? true\n        : false,\n      fScore: Infinity,\n      row\n    };\n  };\n\n  //Event Handlers\n\n  const handleMouseDown = (row, col) => {\n    if (visualizerOnBoard.current) return;\n    mouseDownRef.current = true;\n    if (\n      row === checkPointPosRef.current[0] &&\n      col === checkPointPosRef.current[1]\n    ) {\n      checkPointMovingRef.current = true;\n      return;\n    }\n    if (\n      row === startNodePosRef.current[0] &&\n      col === startNodePosRef.current[1]\n    ) {\n      startNodeMovingRef.current = true;\n      return;\n    }\n    if (\n      row === finishNodePosRef.current[0] &&\n      col === finishNodePosRef.current[1]\n    ) {\n      finishNodeMovingRef.current = true;\n      return;\n    }\n    setGrid(getNewGridWithWallToggled(row, col));\n  };\n\n  const handleMouseEnter = (row, col) => {\n    if (!mouseDownRef.current) return;\n    if (checkPointMovingRef.current) {\n      checkPointPosRef.current = [row, col];\n      const newGrid = getGrid(false, checkPointOnBoard.current);\n      setGrid(newGrid);\n      return;\n    }\n    if (startNodeMovingRef.current) {\n      startNodePosRef.current = [row, col];\n      const newGrid = getGrid(false, checkPointOnBoard.current);\n      setGrid(newGrid);\n      return;\n    }\n    if (finishNodeMovingRef.current) {\n      finishNodePosRef.current = [row, col];\n      const newGrid = getGrid(false, checkPointOnBoard.current);\n      setGrid(newGrid);\n      return;\n    }\n    if (\n      (row !== startNodePosRef.current[0] ||\n        col !== startNodePosRef.current[1]) &&\n      (row !== finishNodePosRef.current[0] ||\n        col !== finishNodePosRef.current[1]) &&\n      (row !== checkPointPosRef.current[0] ||\n        col !== checkPointPosRef.current[1])\n    )\n      setGrid(getNewGridWithWallToggled(row, col));\n  };\n\n  const handleMouseUp = () => {\n    finishNodeMovingRef.current = false;\n    startNodeMovingRef.current = false;\n    checkPointMovingRef.current = false;\n    mouseDownRef.current = false;\n  };\n\n  const handleRestart = () => {\n    if (visualizerIsRunning.current) return;\n    visualizerOnBoard.current = false;\n    checkPointOnBoard.current = false;\n    addCheckPointOnNav.current = true;\n    //restarts start and finish nodes\n    startNodePosRef.current = [10, 15];\n    finishNodePosRef.current = [10, 35];\n    setGrid(getGrid(true, checkPointOnBoard.current));\n  };\n\n  const handleClearVisualization = () => {\n    if (visualizerIsRunning.current) return;\n    visualizerOnBoard.current = false;\n    setGrid(getGrid(false, checkPointOnBoard.current));\n  };\n\n  const handleClearBarriers = () => {\n    if (visualizerOnBoard.current) return;\n    setGrid(getGrid(true, checkPointOnBoard.current));\n  };\n\n  const handleAddCheckPoint = () => {\n    if (visualizerOnBoard.current) return;\n    checkPointOnBoard.current = !checkPointOnBoard.current;\n    addCheckPointOnNav.current = !addCheckPointOnNav.current;\n    setGrid(getGrid(false, checkPointOnBoard.current));\n  };\n\n  return (\n    <>\n      <NavBar\n        visualizeAlgorithm={visualizeAlgorithm}\n        onClearVis={handleClearVisualization}\n        onRestart={handleRestart}\n        onClearBarriers={handleClearBarriers}\n        onAddCheckPoint={handleAddCheckPoint}\n        add={addCheckPointOnNav.current}\n      />\n      <div className=\"grid\">\n        {grid.map((row, rowIdx) => {\n          return (\n            <div key={rowIdx}>\n              {row.map((node, nodeIdx) => {\n                const {\n                  row,\n                  isStart,\n                  isFinish,\n                  inShortestPath,\n                  isVisited,\n                  isWall,\n                  isCheckPoint,\n                  col\n                } = node;\n                return (\n                  <Node\n                    col={col}\n                    key={nodeIdx}\n                    isFinish={isFinish}\n                    isStart={isStart}\n                    inShortestPath={inShortestPath}\n                    isVisited={isVisited}\n                    isWall={isWall}\n                    isCheckPoint={isCheckPoint}\n                    onMouseUp={handleMouseUp}\n                    onMouseDown={handleMouseDown}\n                    onMouseEnter={handleMouseEnter}\n                    row={row}\n                  ></Node>\n                );\n              })}\n            </div>\n          );\n        })}\n      </div>\n      <div className=\"credit\">By Jason Vail</div>\n    </>\n  );\n};\n\nexport default PathfindingVisualizer;\n","import \"./App.css\";\nimport PathfindingVisualizer from \"./PathfindingVisualizer/PathfindingVisualizer.jsx\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer />\n    </div>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}